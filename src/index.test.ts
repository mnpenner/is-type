import * as lib from './index'

test(lib.isFunction.name, () => {
    expect(lib.isFunction(() => {})).toBe(true)
    expect(lib.isFunction(function(){})).toBe(true)
    expect(lib.isFunction(function fn(){})).toBe(true)
    expect(lib.isFunction(new Date().valueOf)).toBe(true)
    expect(lib.isFunction(Function.prototype)).toBe(true)

    expect(lib.isFunction(function*(){})).toBe(true)
    expect(lib.isFunction(function* named(){})).toBe(true)

    expect(lib.isFunction(async function(){})).toBe(true)
    expect(lib.isFunction(async ()=>{})).toBe(true)

    expect(lib.isFunction(null)).toBe(false)
    expect(lib.isFunction(undefined)).toBe(false)
    expect(lib.isFunction(false)).toBe(false)
    expect(lib.isFunction(true)).toBe(false)
    expect(lib.isFunction('str')).toBe(false)
    expect(lib.isFunction(3.14)).toBe(false)
    expect(lib.isFunction(Symbol())).toBe(false)
    expect(lib.isFunction(/re/)).toBe(false)
    expect(lib.isFunction([])).toBe(false)
    expect(lib.isFunction({})).toBe(false)
    expect(lib.isFunction(Object.create(null))).toBe(false)
    expect(lib.isFunction(new Date)).toBe(false)
    expect(lib.isFunction(new Set())).toBe(false)
    expect(lib.isFunction(new Map())).toBe(false)
})

test(lib.isGeneratorFunction.name, () => {
    expect(lib.isGeneratorFunction(function*(){})).toBe(true)
    expect(lib.isGeneratorFunction(function* named(){})).toBe(true)

    expect(lib.isGeneratorFunction(async function(){})).toBe(false)
    expect(lib.isGeneratorFunction(async ()=>{})).toBe(false)

    expect(lib.isGeneratorFunction(() => {})).toBe(false)
    expect(lib.isGeneratorFunction(function(){})).toBe(false)
    expect(lib.isGeneratorFunction(function fn(){})).toBe(false)
    expect(lib.isGeneratorFunction(new Date().valueOf)).toBe(false)
    expect(lib.isGeneratorFunction(Function.prototype)).toBe(false)

    expect(lib.isGeneratorFunction(null)).toBe(false)
    expect(lib.isGeneratorFunction(undefined)).toBe(false)
    expect(lib.isGeneratorFunction(false)).toBe(false)
    expect(lib.isGeneratorFunction(true)).toBe(false)
    expect(lib.isGeneratorFunction('str')).toBe(false)
    expect(lib.isGeneratorFunction(3.14)).toBe(false)
    expect(lib.isGeneratorFunction(Symbol())).toBe(false)
    expect(lib.isGeneratorFunction(/re/)).toBe(false)
    expect(lib.isGeneratorFunction([])).toBe(false)
    expect(lib.isGeneratorFunction({})).toBe(false)
    expect(lib.isGeneratorFunction(Object.create(null))).toBe(false)
    expect(lib.isGeneratorFunction(new Date)).toBe(false)
    expect(lib.isGeneratorFunction(new Set())).toBe(false)
    expect(lib.isGeneratorFunction(new Map())).toBe(false)
})

test(lib.isAsyncFunction.name, () => {
    expect(lib.isAsyncFunction(async function(){})).toBe(true)
    expect(lib.isAsyncFunction(async ()=>{})).toBe(true)

    expect(lib.isAsyncFunction(function*(){})).toBe(false)
    expect(lib.isAsyncFunction(function* named(){})).toBe(false)

    expect(lib.isAsyncFunction(() => {})).toBe(false)
    expect(lib.isAsyncFunction(function(){})).toBe(false)
    expect(lib.isAsyncFunction(function fn(){})).toBe(false)
    expect(lib.isAsyncFunction(new Date().valueOf)).toBe(false)
    expect(lib.isAsyncFunction(Function.prototype)).toBe(false)

    expect(lib.isAsyncFunction(null)).toBe(false)
    expect(lib.isAsyncFunction(undefined)).toBe(false)
    expect(lib.isAsyncFunction(false)).toBe(false)
    expect(lib.isAsyncFunction(true)).toBe(false)
    expect(lib.isAsyncFunction('str')).toBe(false)
    expect(lib.isAsyncFunction(3.14)).toBe(false)
    expect(lib.isAsyncFunction(Symbol())).toBe(false)
    expect(lib.isAsyncFunction(/re/)).toBe(false)
    expect(lib.isAsyncFunction([])).toBe(false)
    expect(lib.isAsyncFunction({})).toBe(false)
    expect(lib.isAsyncFunction(Object.create(null))).toBe(false)
    expect(lib.isAsyncFunction(new Date)).toBe(false)
    expect(lib.isAsyncFunction(new Set())).toBe(false)
    expect(lib.isAsyncFunction(new Map())).toBe(false)
})

test(lib.isDate.name, () => {
    expect(lib.isDate(new Date)).toBe(true)
    expect(lib.isDate(new Date('2023-01-28T21:28:58.644Z'))).toBe(true)
    expect(lib.isDate(new Date(1674941348908))).toBe(true)
    expect(lib.isDate(new Date(2023,0,28,13,30,59,4321))).toBe(true)

    expect(lib.isDate(new Date('invalid'))).toBe(true)

    expect(lib.isDate(null)).toBe(false)
    expect(lib.isDate(undefined)).toBe(false)
    expect(lib.isDate(false)).toBe(false)
    expect(lib.isDate(true)).toBe(false)
    expect(lib.isDate(/re/)).toBe(false)
    expect(lib.isDate(() => {})).toBe(false)
    expect(lib.isDate('str')).toBe(false)
    expect(lib.isDate(3.14)).toBe(false)
    expect(lib.isDate(Symbol())).toBe(false)
    expect(lib.isDate(new Set())).toBe(false)
    expect(lib.isDate(new Map())).toBe(false)
    expect(lib.isDate([])).toBe(false)
    expect(lib.isDate({})).toBe(false)
    expect(lib.isDate(Object.create(null))).toBe(false)
})

test(lib.isValidDate.name, () => {
    expect(lib.isValidDate(new Date)).toBe(true)
    expect(lib.isValidDate(new Date('2023-01-28T21:28:58.644Z'))).toBe(true)
    expect(lib.isValidDate(new Date(1674941348908))).toBe(true)
    expect(lib.isValidDate(new Date(2023,0,28,13,30,59,4321))).toBe(true)

    expect(lib.isValidDate(new Date('invalid'))).toBe(false)

    expect(lib.isValidDate(null)).toBe(false)
    expect(lib.isValidDate(undefined)).toBe(false)
    expect(lib.isValidDate(false)).toBe(false)
    expect(lib.isValidDate(true)).toBe(false)
    expect(lib.isValidDate(/re/)).toBe(false)
    expect(lib.isValidDate(() => {})).toBe(false)
    expect(lib.isValidDate('str')).toBe(false)
    expect(lib.isValidDate(3.14)).toBe(false)
    expect(lib.isValidDate(Symbol())).toBe(false)
    expect(lib.isValidDate(new Set())).toBe(false)
    expect(lib.isValidDate(new Map())).toBe(false)
    expect(lib.isValidDate([])).toBe(false)
    expect(lib.isValidDate({})).toBe(false)
    expect(lib.isValidDate(Object.create(null))).toBe(false)
})

test(lib.isIterable.name, () => {
    expect(lib.isIterable(null)).toBe(false)
    expect(lib.isIterable(undefined)).toBe(false)
    expect(lib.isIterable(false)).toBe(false)
    expect(lib.isIterable(true)).toBe(false)
    expect(lib.isIterable(/re/)).toBe(false)
    expect(lib.isIterable(() => {})).toBe(false)
    expect(lib.isIterable('str')).toBe(false)
    expect(lib.isIterable(3.14)).toBe(false)
    expect(lib.isIterable(Symbol())).toBe(false)
    expect(lib.isIterable(new Date)).toBe(false)
    expect(lib.isIterable(new Set())).toBe(true)
    expect(lib.isIterable(new Map())).toBe(true)
    expect(lib.isIterable([])).toBe(true)
    expect(lib.isIterable({})).toBe(false)
    expect(lib.isIterable(Object.create(null))).toBe(false)
    expect(lib.isIterable(Object.entries({}))).toBe(true)
    expect(lib.isIterable(Object.entries(Object.create(null)))).toBe(true)
    expect(lib.isIterable(Object.keys({}))).toBe(true)
    expect(lib.isIterable(Object.values({}))).toBe(true)
    expect(lib.isIterable(function*(){}())).toBe(true)
})


test(lib.isNumber.name, () => {
    expect(lib.isNumber(3.14)).toBe(true)
    expect(lib.isNumber(Infinity)).toBe(true)
    expect(lib.isNumber(NaN)).toBe(true)
    expect(lib.isNumber(-Infinity)).toBe(true)
    expect(lib.isNumber(0)).toBe(true)
    expect(lib.isNumber(-0)).toBe(true)

    expect(lib.isNumber(null)).toBe(false)
    expect(lib.isNumber(undefined)).toBe(false)
    expect(lib.isNumber(false)).toBe(false)
    expect(lib.isNumber(true)).toBe(false)
    expect(lib.isNumber(/re/)).toBe(false)
    expect(lib.isNumber(() => {})).toBe(false)
    expect(lib.isNumber('str')).toBe(false)
    expect(lib.isNumber(Symbol())).toBe(false)
    expect(lib.isNumber(new Date)).toBe(false)
    expect(lib.isNumber(new Set())).toBe(false)
    expect(lib.isNumber(new Map())).toBe(false)
    expect(lib.isNumber([])).toBe(false)
    expect(lib.isNumber({})).toBe(false)
    expect(lib.isNumber(Object.create(null))).toBe(false)
})

test(lib.isFiniteNumber.name, () => {
    expect(lib.isFiniteNumber(3.14)).toBe(true)
    expect(lib.isFiniteNumber(0)).toBe(true)
    expect(lib.isFiniteNumber(-0)).toBe(true)

    expect(lib.isFiniteNumber(Infinity)).toBe(false)
    expect(lib.isFiniteNumber(NaN)).toBe(false)
    expect(lib.isFiniteNumber(-Infinity)).toBe(false)

    expect(lib.isFiniteNumber(null)).toBe(false)
    expect(lib.isFiniteNumber(undefined)).toBe(false)
    expect(lib.isFiniteNumber(false)).toBe(false)
    expect(lib.isFiniteNumber(true)).toBe(false)
    expect(lib.isFiniteNumber(/re/)).toBe(false)
    expect(lib.isFiniteNumber(() => {})).toBe(false)
    expect(lib.isFiniteNumber('str')).toBe(false)
    expect(lib.isFiniteNumber(Symbol())).toBe(false)
    expect(lib.isFiniteNumber(new Date)).toBe(false)
    expect(lib.isFiniteNumber(new Set())).toBe(false)
    expect(lib.isFiniteNumber(new Map())).toBe(false)
    expect(lib.isFiniteNumber([])).toBe(false)
    expect(lib.isFiniteNumber({})).toBe(false)
    expect(lib.isFiniteNumber(Object.create(null))).toBe(false)
})

test(lib.isInteger.name, () => {
    expect(lib.isInteger(0)).toBe(true)
    expect(lib.isInteger(-0)).toBe(true)
    expect(lib.isInteger(3)).toBe(true)
    expect(lib.isInteger(Number.MAX_SAFE_INTEGER)).toBe(true)
    expect(lib.isInteger(Number.MIN_SAFE_INTEGER)).toBe(true)
    expect(lib.isInteger(Number.MAX_SAFE_INTEGER+1)).toBe(true)

    expect(lib.isInteger(3.14)).toBe(false)
    expect(lib.isInteger(Infinity)).toBe(false)
    expect(lib.isInteger(NaN)).toBe(false)
    expect(lib.isInteger(-Infinity)).toBe(false)

    expect(lib.isInteger(null)).toBe(false)
    expect(lib.isInteger(undefined)).toBe(false)
    expect(lib.isInteger(false)).toBe(false)
    expect(lib.isInteger(true)).toBe(false)
    expect(lib.isInteger(/re/)).toBe(false)
    expect(lib.isInteger(() => {})).toBe(false)
    expect(lib.isInteger('str')).toBe(false)
    expect(lib.isInteger(Symbol())).toBe(false)
    expect(lib.isInteger(new Date)).toBe(false)
    expect(lib.isInteger(new Set())).toBe(false)
    expect(lib.isInteger(new Map())).toBe(false)
    expect(lib.isInteger([])).toBe(false)
    expect(lib.isInteger({})).toBe(false)
    expect(lib.isInteger(Object.create(null))).toBe(false)
})

test(lib.isSafeInteger.name, () => {
    expect(lib.isSafeInteger(0)).toBe(true)
    expect(lib.isSafeInteger(-0)).toBe(true)
    expect(lib.isSafeInteger(3)).toBe(true)
    expect(lib.isSafeInteger(Number.MAX_SAFE_INTEGER)).toBe(true)
    expect(lib.isSafeInteger(Number.MIN_SAFE_INTEGER)).toBe(true)

    expect(lib.isSafeInteger(Number.MAX_SAFE_INTEGER+1)).toBe(false)
    expect(lib.isSafeInteger(3.14)).toBe(false)
    expect(lib.isSafeInteger(Infinity)).toBe(false)
    expect(lib.isSafeInteger(NaN)).toBe(false)
    expect(lib.isSafeInteger(-Infinity)).toBe(false)

    expect(lib.isSafeInteger(null)).toBe(false)
    expect(lib.isSafeInteger(undefined)).toBe(false)
    expect(lib.isSafeInteger(false)).toBe(false)
    expect(lib.isSafeInteger(true)).toBe(false)
    expect(lib.isSafeInteger(/re/)).toBe(false)
    expect(lib.isSafeInteger(() => {})).toBe(false)
    expect(lib.isSafeInteger('str')).toBe(false)
    expect(lib.isSafeInteger(Symbol())).toBe(false)
    expect(lib.isSafeInteger(new Date)).toBe(false)
    expect(lib.isSafeInteger(new Set())).toBe(false)
    expect(lib.isSafeInteger(new Map())).toBe(false)
    expect(lib.isSafeInteger([])).toBe(false)
    expect(lib.isSafeInteger({})).toBe(false)
    expect(lib.isSafeInteger(Object.create(null))).toBe(false)
})


test(lib.isBitSafeInteger.name, () => {
    expect(lib.isBitSafeInteger(0)).toBe(true)
    expect(lib.isBitSafeInteger(-0)).toBe(true)
    expect(lib.isBitSafeInteger(3)).toBe(true)

    expect(lib.isBitSafeInteger(2**31-1)).toBe(true)
    expect(lib.isBitSafeInteger(2**31)).toBe(false)

    expect(lib.isBitSafeInteger(-(2**31+1))).toBe(false)
    expect(lib.isBitSafeInteger(-(2**31))).toBe(true)

    expect(lib.isBitSafeInteger(Number.MAX_SAFE_INTEGER)).toBe(false)
    expect(lib.isBitSafeInteger(Number.MIN_SAFE_INTEGER)).toBe(false)
    expect(lib.isBitSafeInteger(Number.MAX_SAFE_INTEGER+1)).toBe(false)
    expect(lib.isBitSafeInteger(3.14)).toBe(false)
    expect(lib.isBitSafeInteger(Infinity)).toBe(false)
    expect(lib.isBitSafeInteger(NaN)).toBe(false)
    expect(lib.isBitSafeInteger(-Infinity)).toBe(false)

    expect(lib.isBitSafeInteger(null)).toBe(false)
    expect(lib.isBitSafeInteger(undefined)).toBe(false)
    expect(lib.isBitSafeInteger(false)).toBe(false)
    expect(lib.isBitSafeInteger(true)).toBe(false)
    expect(lib.isBitSafeInteger(/re/)).toBe(false)
    expect(lib.isBitSafeInteger(() => {})).toBe(false)
    expect(lib.isBitSafeInteger('str')).toBe(false)
    expect(lib.isBitSafeInteger(Symbol())).toBe(false)
    expect(lib.isBitSafeInteger(new Date)).toBe(false)
    expect(lib.isBitSafeInteger(new Set())).toBe(false)
    expect(lib.isBitSafeInteger(new Map())).toBe(false)
    expect(lib.isBitSafeInteger([])).toBe(false)
    expect(lib.isBitSafeInteger({})).toBe(false)
    expect(lib.isBitSafeInteger(Object.create(null))).toBe(false)
})

test(lib.isBigInt.name, () => {
    expect(lib.isBigInt(0n)).toBe(true)
    expect(lib.isBigInt(1n)).toBe(true)
    expect(lib.isBigInt(BigInt('0'))).toBe(true)

    expect(lib.isBigInt(0)).toBe(false)
    expect(lib.isBigInt(-0)).toBe(false)
    expect(lib.isBigInt(3)).toBe(false)

    expect(lib.isBigInt(2**31-1)).toBe(false)
    expect(lib.isBigInt(2**31)).toBe(false)

    expect(lib.isBigInt(-(2**31+1))).toBe(false)
    expect(lib.isBigInt(-(2**31))).toBe(false)

    expect(lib.isBigInt(Number.MAX_SAFE_INTEGER)).toBe(false)
    expect(lib.isBigInt(Number.MIN_SAFE_INTEGER)).toBe(false)
    expect(lib.isBigInt(Number.MAX_SAFE_INTEGER+1)).toBe(false)
    expect(lib.isBigInt(3.14)).toBe(false)
    expect(lib.isBigInt(Infinity)).toBe(false)
    expect(lib.isBigInt(NaN)).toBe(false)
    expect(lib.isBigInt(-Infinity)).toBe(false)

    expect(lib.isBigInt(null)).toBe(false)
    expect(lib.isBigInt(undefined)).toBe(false)
    expect(lib.isBigInt(false)).toBe(false)
    expect(lib.isBigInt(true)).toBe(false)
    expect(lib.isBigInt(/re/)).toBe(false)
    expect(lib.isBigInt(() => {})).toBe(false)
    expect(lib.isBigInt('str')).toBe(false)
    expect(lib.isBigInt(Symbol())).toBe(false)
    expect(lib.isBigInt(new Date)).toBe(false)
    expect(lib.isBigInt(new Set())).toBe(false)
    expect(lib.isBigInt(new Map())).toBe(false)
    expect(lib.isBigInt([])).toBe(false)
    expect(lib.isBigInt({})).toBe(false)
    expect(lib.isBigInt(Object.create(null))).toBe(false)
})


test(lib.isFloat.name, () => {
    expect(lib.isFloat(3.14)).toBe(true)
    expect(lib.isFloat(-3.14)).toBe(true)
    expect(lib.isFloat(Number.MIN_VALUE)).toBe(true)

    expect(lib.isFloat(0)).toBe(false)
    expect(lib.isFloat(-0)).toBe(false)
    expect(lib.isFloat(3)).toBe(false)

    expect(lib.isFloat(2**31-1)).toBe(false)
    expect(lib.isFloat(2**31)).toBe(false)

    expect(lib.isFloat(-(2**31+1))).toBe(false)
    expect(lib.isFloat(-(2**31))).toBe(false)

    expect(lib.isFloat(Number.MAX_SAFE_INTEGER)).toBe(false)
    expect(lib.isFloat(Number.MIN_SAFE_INTEGER)).toBe(false)
    expect(lib.isFloat(Number.MAX_SAFE_INTEGER+1)).toBe(false)
    expect(lib.isFloat(Number.MAX_SAFE_INTEGER+2)).toBe(false)
    expect(lib.isFloat(Infinity)).toBe(false)
    expect(lib.isFloat(NaN)).toBe(false)
    expect(lib.isFloat(-Infinity)).toBe(false)

    expect(lib.isFloat(null)).toBe(false)
    expect(lib.isFloat(undefined)).toBe(false)
    expect(lib.isFloat(false)).toBe(false)
    expect(lib.isFloat(true)).toBe(false)
    expect(lib.isFloat(/re/)).toBe(false)
    expect(lib.isFloat(() => {})).toBe(false)
    expect(lib.isFloat('str')).toBe(false)
    expect(lib.isFloat(Symbol())).toBe(false)
    expect(lib.isFloat(new Date)).toBe(false)
    expect(lib.isFloat(new Set())).toBe(false)
    expect(lib.isFloat(new Map())).toBe(false)
    expect(lib.isFloat([])).toBe(false)
    expect(lib.isFloat({})).toBe(false)
    expect(lib.isFloat(Object.create(null))).toBe(false)
})

test(lib.isSet.name, () => {
    expect(lib.isSet(null)).toBe(false)
    expect(lib.isSet(undefined)).toBe(false)
    expect(lib.isSet(false)).toBe(false)
    expect(lib.isSet(true)).toBe(false)
    expect(lib.isSet('str')).toBe(false)
    expect(lib.isSet(3.14)).toBe(false)
    expect(lib.isSet(Symbol())).toBe(false)
    expect(lib.isSet(/re/)).toBe(false)
    expect(lib.isSet([])).toBe(false)
    expect(lib.isSet({})).toBe(false)
    expect(lib.isSet(() => {})).toBe(false)
    expect(lib.isSet(Object.create(null))).toBe(false)
    expect(lib.isSet(new Date)).toBe(false)
    expect(lib.isSet(new Set())).toBe(true)
    expect(lib.isSet(new Map())).toBe(false)
})

test(lib.isMap.name, () => {
    expect(lib.isMap(null)).toBe(false)
    expect(lib.isMap(undefined)).toBe(false)
    expect(lib.isMap(false)).toBe(false)
    expect(lib.isMap(true)).toBe(false)
    expect(lib.isMap('str')).toBe(false)
    expect(lib.isMap(3.14)).toBe(false)
    expect(lib.isMap(Symbol())).toBe(false)
    expect(lib.isMap(/re/)).toBe(false)
    expect(lib.isMap([])).toBe(false)
    expect(lib.isMap({})).toBe(false)
    expect(lib.isMap(() => {})).toBe(false)
    expect(lib.isMap(Object.create(null))).toBe(false)
    expect(lib.isMap(new Date)).toBe(false)
    expect(lib.isMap(new Set())).toBe(false)
    expect(lib.isMap(new Map())).toBe(true)
})

test(lib.isArray.name, () => {
    expect(lib.isArray([])).toBe(true)
    expect(lib.isArray(Array(5))).toBe(true)
    expect(lib.isArray(Array.from({length:5}))).toBe(true)

    expect(lib.isArray(null)).toBe(false)
    expect(lib.isArray(undefined)).toBe(false)
    expect(lib.isArray(false)).toBe(false)
    expect(lib.isArray(true)).toBe(false)
    expect(lib.isArray('str')).toBe(false)
    expect(lib.isArray(3.14)).toBe(false)
    expect(lib.isArray(Symbol())).toBe(false)
    expect(lib.isArray(/re/)).toBe(false)
    expect(lib.isArray({})).toBe(false)
    expect(lib.isArray(() => {})).toBe(false)
    expect(lib.isArray(Object.create(null))).toBe(false)
    expect(lib.isArray(new Date)).toBe(false)
    expect(lib.isArray(new Set())).toBe(false)
    expect(lib.isArray(new Map())).toBe(false)
})

test(lib.isObject.name, () => {
    expect(lib.isObject(/re/)).toBe(true)
    expect(lib.isObject([])).toBe(true)
    expect(lib.isObject({})).toBe(true)
    expect(lib.isObject(Object.create(null))).toBe(true)
    expect(lib.isObject(new Date)).toBe(true)
    expect(lib.isObject(new Set())).toBe(true)
    expect(lib.isObject(new Map())).toBe(true)
    expect(lib.isObject(Math)).toBe(true)
    expect(lib.isObject(Error)).toBe(true)

    expect(lib.isObject(() => {})).toBe(true)

    expect(lib.isObject(null)).toBe(false)
    expect(lib.isObject(undefined)).toBe(false)
    expect(lib.isObject(false)).toBe(false)
    expect(lib.isObject(true)).toBe(false)
    expect(lib.isObject('str')).toBe(false)
    expect(lib.isObject(3.14)).toBe(false)
    expect(lib.isObject(Symbol())).toBe(false)
})

test(lib.isObjectLike.name, () => {
    expect(lib.isObjectLike(/re/)).toBe(true)
    expect(lib.isObjectLike([])).toBe(true)
    expect(lib.isObjectLike({})).toBe(true)
    expect(lib.isObjectLike(Object.create(null))).toBe(true)
    expect(lib.isObjectLike(new Date)).toBe(true)
    expect(lib.isObjectLike(new Set())).toBe(true)
    expect(lib.isObjectLike(new Map())).toBe(true)
    expect(lib.isObject(Math)).toBe(true)
    expect(lib.isObject(Error)).toBe(true)

    expect(lib.isObjectLike(() => {})).toBe(false)

    expect(lib.isObjectLike(null)).toBe(false)
    expect(lib.isObjectLike(undefined)).toBe(false)
    expect(lib.isObjectLike(false)).toBe(false)
    expect(lib.isObjectLike(true)).toBe(false)
    expect(lib.isObjectLike('str')).toBe(false)
    expect(lib.isObjectLike(3.14)).toBe(false)
    expect(lib.isObjectLike(Symbol())).toBe(false)
})

describe(lib.isPojo.name, () => {
    function Foo(this: any, a: number) {
        this.a = a;
    }

    it('should detect plain objects', () => {
        expect(lib.isPojo({})).toBe(true)
        expect(lib.isPojo({__proto__:null})).toBe(true)
        expect(lib.isPojo(Object.create(null))).toBe(true)
        expect(lib.isPojo({'constructor':Foo})).toBe(true)
        expect(lib.isPojo({valueOf:0})).toBe(true)
        expect(lib.isPojo({[Symbol()]:5})).toBe(true)
    })

    it('should return `false` for objects with a non-Object `Symbol.toStringTag` property', () => {
        expect(lib.isPojo({[Symbol.toStringTag]: 'X'})).toBe(false)
    })

    it('should return `false` for objects with a custom `[[Prototype]]`', () => {
        expect(lib.isPojo(Object.create({a:1}))).toBe(false)
        expect(lib.isPojo(Object.create(Foo))).toBe(false)
        expect(lib.isPojo({__proto__:{a:1}})).toBe(false)
        expect(lib.isPojo({__proto__:Foo})).toBe(false)
    })

    it('should return `false` for built-ins', function() {
        expect(lib.isPojo(arguments)).toBe(false)
        expect(lib.isPojo(Error)).toBe(false)
        expect(lib.isPojo(Math)).toBe(false)
    });

    it('should return false for non-plain objects', () => {
        expect(lib.isPojo(/re/)).toBe(false)
        expect(lib.isPojo([])).toBe(false)
        expect(lib.isPojo(new Date)).toBe(false)
        expect(lib.isPojo(new Set())).toBe(false)
        expect(lib.isPojo(new Map())).toBe(false)
        expect(lib.isPojo(() => {})).toBe(false)
    })

    it('should return false for non-objects', () => {
        expect(lib.isPojo(null)).toBe(false)
        expect(lib.isPojo(undefined)).toBe(false)
        expect(lib.isPojo(false)).toBe(false)
        expect(lib.isPojo(true)).toBe(false)
        expect(lib.isPojo('str')).toBe(false)
        expect(lib.isPojo(3.14)).toBe(false)
        expect(lib.isPojo(Symbol())).toBe(false)
    })
})

test(lib.isSymbol.name, () => {
    expect(lib.isSymbol(Symbol())).toBe(true)
    expect(lib.isSymbol(Symbol('sym'))).toBe(true)
    expect(lib.isSymbol(Symbol.for('test'))).toBe(true)

    expect(lib.isSymbol(/re/)).toBe(false)
    expect(lib.isSymbol([])).toBe(false)
    expect(lib.isSymbol({})).toBe(false)
    expect(lib.isSymbol(Object.create(null))).toBe(false)
    expect(lib.isSymbol(new Date)).toBe(false)
    expect(lib.isSymbol(new Set())).toBe(false)
    expect(lib.isSymbol(new Map())).toBe(false)
    expect(lib.isSymbol(Math)).toBe(false)
    expect(lib.isSymbol(Error)).toBe(false)
    expect(lib.isSymbol(() => {})).toBe(false)
    expect(lib.isSymbol(null)).toBe(false)
    expect(lib.isSymbol(undefined)).toBe(false)
    expect(lib.isSymbol(false)).toBe(false)
    expect(lib.isSymbol(true)).toBe(false)
    expect(lib.isSymbol('str')).toBe(false)
    expect(lib.isSymbol(3.14)).toBe(false)
})

test(lib.isTruthy.name, () => {
    expect(lib.isTruthy(false)).toBe(false)
    expect(lib.isTruthy(0)).toBe(false)
    expect(lib.isTruthy(-0)).toBe(false)
    expect(lib.isTruthy(0n)).toBe(false)
    expect(lib.isTruthy(NaN)).toBe(false)
    expect(lib.isTruthy(undefined)).toBe(false)
    expect(lib.isTruthy(null)).toBe(false)
    expect(lib.isTruthy('')).toBe(false)

    expect(lib.isTruthy(Symbol())).toBe(true)
    expect(lib.isTruthy(Symbol('sym'))).toBe(true)
    expect(lib.isTruthy(Symbol.for('test'))).toBe(true)
    expect(lib.isTruthy(/re/)).toBe(true)
    expect(lib.isTruthy([])).toBe(true)
    expect(lib.isTruthy({})).toBe(true)
    expect(lib.isTruthy(Object.create(null))).toBe(true)
    expect(lib.isTruthy(new Date)).toBe(true)
    expect(lib.isTruthy(new Set())).toBe(true)
    expect(lib.isTruthy(new Map())).toBe(true)
    expect(lib.isTruthy(Math)).toBe(true)
    expect(lib.isTruthy(Error)).toBe(true)
    expect(lib.isTruthy(() => {})).toBe(true)
    expect(lib.isTruthy(true)).toBe(true)
    expect(lib.isTruthy('str')).toBe(true)
    expect(lib.isTruthy(3.14)).toBe(true)
})

test(lib.isFalsy.name, () => {
    expect(lib.isFalsy(false)).toBe(true)
    expect(lib.isFalsy(0)).toBe(true)
    expect(lib.isFalsy(-0)).toBe(true)
    expect(lib.isFalsy(0n)).toBe(true)
    expect(lib.isFalsy(NaN)).toBe(true)
    expect(lib.isFalsy(undefined)).toBe(true)
    expect(lib.isFalsy(null)).toBe(true)
    expect(lib.isFalsy('')).toBe(true)

    expect(lib.isFalsy(Symbol())).toBe(false)
    expect(lib.isFalsy(Symbol('sym'))).toBe(false)
    expect(lib.isFalsy(Symbol.for('test'))).toBe(false)
    expect(lib.isFalsy(/re/)).toBe(false)
    expect(lib.isFalsy([])).toBe(false)
    expect(lib.isFalsy({})).toBe(false)
    expect(lib.isFalsy(Object.create(null))).toBe(false)
    expect(lib.isFalsy(new Date)).toBe(false)
    expect(lib.isFalsy(new Set())).toBe(false)
    expect(lib.isFalsy(new Map())).toBe(false)
    expect(lib.isFalsy(Math)).toBe(false)
    expect(lib.isFalsy(Error)).toBe(false)
    expect(lib.isFalsy(() => {})).toBe(false)
    expect(lib.isFalsy(true)).toBe(false)
    expect(lib.isFalsy('str')).toBe(false)
    expect(lib.isFalsy(3.14)).toBe(false)
})

test(lib.isRegExp.name, () => {
    expect(lib.isRegExp(/re/)).toBe(true)
    expect(lib.isRegExp(new RegExp('re','i'))).toBe(true)

    expect(lib.isRegExp(Symbol())).toBe(false)
    expect(lib.isRegExp([])).toBe(false)
    expect(lib.isRegExp({})).toBe(false)
    expect(lib.isRegExp(Object.create(null))).toBe(false)
    expect(lib.isRegExp(new Date)).toBe(false)
    expect(lib.isRegExp(new Set())).toBe(false)
    expect(lib.isRegExp(new Map())).toBe(false)
    expect(lib.isRegExp(Math)).toBe(false)
    expect(lib.isRegExp(Error)).toBe(false)
    expect(lib.isRegExp(() => {})).toBe(false)
    expect(lib.isRegExp(true)).toBe(false)
    expect(lib.isRegExp('str')).toBe(false)
    expect(lib.isRegExp(3.14)).toBe(false)
})

test(lib.isError.name, () => {
    expect(lib.isError(new Error('foo'))).toBe(true)
    expect(lib.isError(Error)).toBe(false)

    expect(lib.isError(Symbol())).toBe(false)
    expect(lib.isError([])).toBe(false)
    expect(lib.isError({})).toBe(false)
    expect(lib.isError(Object.create(null))).toBe(false)
    expect(lib.isError(new Date)).toBe(false)
    expect(lib.isError(new Set())).toBe(false)
    expect(lib.isError(new Map())).toBe(false)
    expect(lib.isError(Math)).toBe(false)
    expect(lib.isError(/re/)).toBe(false)
    expect(lib.isError(() => {})).toBe(false)
    expect(lib.isError(true)).toBe(false)
    expect(lib.isError('str')).toBe(false)
    expect(lib.isError(3.14)).toBe(false)
})

test(lib.isNull.name, () => {
    expect(lib.isNull(null)).toBe(true)
    expect(lib.isNull(undefined)).toBe(false)

    expect(lib.isNull(Error)).toBe(false)
    expect(lib.isNull(new Error('foo'))).toBe(false)
    expect(lib.isNull(Symbol())).toBe(false)
    expect(lib.isNull([])).toBe(false)
    expect(lib.isNull({})).toBe(false)
    expect(lib.isNull(Object.create(null))).toBe(false)
    expect(lib.isNull(new Date)).toBe(false)
    expect(lib.isNull(new Set())).toBe(false)
    expect(lib.isNull(new Map())).toBe(false)
    expect(lib.isNull(Math)).toBe(false)
    expect(lib.isNull(/re/)).toBe(false)
    expect(lib.isNull(() => {})).toBe(false)
    expect(lib.isNull(true)).toBe(false)
    expect(lib.isNull('str')).toBe(false)
    expect(lib.isNull(3.14)).toBe(false)
})

test(lib.isUndefined.name, () => {
    expect(lib.isUndefined(null)).toBe(false)
    expect(lib.isUndefined(undefined)).toBe(true)

    expect(lib.isUndefined(Error)).toBe(false)
    expect(lib.isUndefined(new Error('foo'))).toBe(false)
    expect(lib.isUndefined(Symbol())).toBe(false)
    expect(lib.isUndefined([])).toBe(false)
    expect(lib.isUndefined({})).toBe(false)
    expect(lib.isUndefined(Object.create(null))).toBe(false)
    expect(lib.isUndefined(new Date)).toBe(false)
    expect(lib.isUndefined(new Set())).toBe(false)
    expect(lib.isUndefined(new Map())).toBe(false)
    expect(lib.isUndefined(Math)).toBe(false)
    expect(lib.isUndefined(/re/)).toBe(false)
    expect(lib.isUndefined(() => {})).toBe(false)
    expect(lib.isUndefined(true)).toBe(false)
    expect(lib.isUndefined('str')).toBe(false)
    expect(lib.isUndefined(3.14)).toBe(false)
})

test(lib.isNullish.name, () => {
    expect(lib.isNullish(null)).toBe(true)
    expect(lib.isNullish(undefined)).toBe(true)

    expect(lib.isNullish(Error)).toBe(false)
    expect(lib.isNullish(new Error('foo'))).toBe(false)
    expect(lib.isNullish(Symbol())).toBe(false)
    expect(lib.isNullish([])).toBe(false)
    expect(lib.isNullish({})).toBe(false)
    expect(lib.isNullish(Object.create(null))).toBe(false)
    expect(lib.isNullish(new Date)).toBe(false)
    expect(lib.isNullish(new Set())).toBe(false)
    expect(lib.isNullish(new Map())).toBe(false)
    expect(lib.isNullish(Math)).toBe(false)
    expect(lib.isNullish(/re/)).toBe(false)
    expect(lib.isNullish(() => {})).toBe(false)
    expect(lib.isNullish(true)).toBe(false)
    expect(lib.isNullish('str')).toBe(false)
    expect(lib.isNullish(3.14)).toBe(false)
})

test(lib.isPrimitive.name, () => {
    expect(lib.isPrimitive(null)).toBe(true)
    expect(lib.isPrimitive(undefined)).toBe(true)
    expect(lib.isPrimitive(0)).toBe(true)
    expect(lib.isPrimitive(0n)).toBe(true)
    expect(lib.isPrimitive(NaN)).toBe(true)
    expect(lib.isPrimitive(true)).toBe(true)
    expect(lib.isPrimitive(false)).toBe(true)
    expect(lib.isPrimitive(Symbol())).toBe(true)
    expect(lib.isPrimitive(Symbol.for('x'))).toBe(true)

    expect(lib.isPrimitive(Error)).toBe(false)
    expect(lib.isPrimitive(new Error('foo'))).toBe(false)
    expect(lib.isPrimitive([])).toBe(false)
    expect(lib.isPrimitive({})).toBe(false)
    expect(lib.isPrimitive(Object.create(null))).toBe(false)
    expect(lib.isPrimitive(new Date)).toBe(false)
    expect(lib.isPrimitive(new Set())).toBe(false)
    expect(lib.isPrimitive(new Map())).toBe(false)
    expect(lib.isPrimitive(Math)).toBe(false)
    expect(lib.isPrimitive(/re/)).toBe(false)
    expect(lib.isPrimitive(() => {})).toBe(false)
})



test(lib.isString.name, () => {
    expect(lib.isString('str')).toBe(true)
    expect(lib.isString(new String('str'))).toBe(false)

    expect(lib.isString(null)).toBe(false)
    expect(lib.isString(undefined)).toBe(false)
    expect(lib.isString(false)).toBe(false)
    expect(lib.isString(true)).toBe(false)
    expect(lib.isString(3.14)).toBe(false)
    expect(lib.isString(Symbol())).toBe(false)
    expect(lib.isString(/re/)).toBe(false)
    expect(lib.isString([])).toBe(false)
    expect(lib.isString({})).toBe(false)
    expect(lib.isString(Object.create(null))).toBe(false)
    expect(lib.isString(new Date)).toBe(false)
    expect(lib.isString(new Set())).toBe(false)
    expect(lib.isString(new Map())).toBe(false)
})

test(lib.isNumberLike.name, () => {
    expect(lib.isNumberLike(3.14)).toBe(true)
    expect(lib.isNumberLike(new Number('3.14'))).toBe(true)

    expect(lib.isNumberLike('str')).toBe(false)
    expect(lib.isNumberLike(new String('str'))).toBe(false)
    expect(lib.isNumberLike(null)).toBe(false)
    expect(lib.isNumberLike(undefined)).toBe(false)
    expect(lib.isNumberLike(false)).toBe(false)
    expect(lib.isNumberLike(true)).toBe(false)
    expect(lib.isNumberLike(Symbol())).toBe(false)
    expect(lib.isNumberLike(/re/)).toBe(false)
    expect(lib.isNumberLike([])).toBe(false)
    expect(lib.isNumberLike({})).toBe(false)
    expect(lib.isNumberLike(Object.create(null))).toBe(false)
    expect(lib.isNumberLike(new Date)).toBe(false)
    expect(lib.isNumberLike(new Set())).toBe(false)
    expect(lib.isNumberLike(new Map())).toBe(false)
})

test(lib.isBoolean.name, () => {
    expect(lib.isBoolean(false)).toBe(true)
    expect(lib.isBoolean(true)).toBe(true)

    expect(lib.isBoolean(new Boolean(true))).toBe(false)

    expect(lib.isBoolean(3.14)).toBe(false)
    expect(lib.isBoolean(new Number('3.14'))).toBe(false)
    expect(lib.isBoolean('str')).toBe(false)
    expect(lib.isBoolean(new String('str'))).toBe(false)
    expect(lib.isBoolean(null)).toBe(false)
    expect(lib.isBoolean(undefined)).toBe(false)
    expect(lib.isBoolean(Symbol())).toBe(false)
    expect(lib.isBoolean(/re/)).toBe(false)
    expect(lib.isBoolean([])).toBe(false)
    expect(lib.isBoolean({})).toBe(false)
    expect(lib.isBoolean(Object.create(null))).toBe(false)
    expect(lib.isBoolean(new Date)).toBe(false)
    expect(lib.isBoolean(new Set())).toBe(false)
    expect(lib.isBoolean(new Map())).toBe(false)
})


test(lib.isBooleanLike.name, () => {
    expect(lib.isBooleanLike(false)).toBe(true)
    expect(lib.isBooleanLike(true)).toBe(true)
    expect(lib.isBooleanLike(new Boolean(true))).toBe(true)

    expect(lib.isBooleanLike(3.14)).toBe(false)
    expect(lib.isBooleanLike(new Number('3.14'))).toBe(false)
    expect(lib.isBooleanLike('str')).toBe(false)
    expect(lib.isBooleanLike(new String('str'))).toBe(false)
    expect(lib.isBooleanLike(null)).toBe(false)
    expect(lib.isBooleanLike(undefined)).toBe(false)
    expect(lib.isBooleanLike(Symbol())).toBe(false)
    expect(lib.isBooleanLike(/re/)).toBe(false)
    expect(lib.isBooleanLike([])).toBe(false)
    expect(lib.isBooleanLike({})).toBe(false)
    expect(lib.isBooleanLike(Object.create(null))).toBe(false)
    expect(lib.isBooleanLike(new Date)).toBe(false)
    expect(lib.isBooleanLike(new Set())).toBe(false)
    expect(lib.isBooleanLike(new Map())).toBe(false)
})
